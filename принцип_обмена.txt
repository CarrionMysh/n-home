опрос мастером слэвов цикличный.

запрос мастера минимум: crc8+номер_слэйва+ask+<байт_heartbit>
ответ слэйва минимум: crc8+номер_слэйва+response+<байт_heartbit>

запрос мастера типовая команда: crc8+ask+номер_слейва+индификатор_команды+?дополнительные_атрибуты?
ответ 1 слэйва типовая команда: crc8+номер_слэйва+response+данные
ответ 2 слэйва на команду: crc8+номер_слэйва+response+ok

пример пакета:  >ff!02#<          -пакет для слэйва id02 с heartbit
        ответ:  >ff&02#<          -ответ слэйва id02 с heartbit
                01234567
             :  >ff!0205<         -запрос на выполнение слэйвом id02 команды 05
                где ff - crc сумма пакета, начиная с заголовка и символом конца пакета
ask:        !
response:   &

heartbit:   #
начало пакета: >
конец пакета: <
коды команд:
    01  отдать значение 1(то что умеет слэйв)
    ..
    09  отдать значение 9
    10  выполнить операцию 1
    ..
    19  выполнить операцию 9

коды ошибок от слэйва:
    99  ошибка целостности пакета
    98  неверная команда
    97  нет данных
    96  ошибка исполнительго девайса
    95  ошибка датчика
    94  ок!

для расчета CRC8 используем часть пакета, начиная с заголовка до последнего символа '<'


update: есть мысли передавать команды и id как char, на стороне клиента конвертировать char в byte. плюсы: массивы строк команд и id не нужны. уменьшение размера пакета в линии в ~2 раза

команды для слэйва освещения:

10 включить (второй байт в data[] яркость)
11 выключить
12 убавить
13 прибавить
14 калибровка
15 выполнить эффект
16 эффект включения
17 эффект выключения
18 отключить реле
19 включить реле

для слэйва данные:
0 все. второй байт = яркость (кроме команды выключения, там последовательно идут номера ламп на выключение)
nn опреденную лампу (номер эффекта): первый байт  = номер лампы. второй байт = яркость лампы
1, 2, .. nn - указанные лампы
